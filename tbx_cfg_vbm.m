function vbm = tbx_cfg_vbm
% Configuration file for Segment jobs
%_______________________________________________________________________
% Copyright (C) 2008 Wellcome Department of Imaging Neuroscience

% based on John Ashburners version of
% tbx_cfg_preproc8.m
%
% Christian Gaser
% $Id$
%
%#ok<*AGROW>
 
%rev = '$Rev$'; % not used

addpath(fileparts(which(mfilename)));
%_______________________________________________________________________

expert = 0; % switch to de/activate further GUI options

data          = cfg_files;
data.tag      = 'data';
data.name     = 'Volumes';
data.filter   = 'image';
data.ufilter  = '.*';
% by default only files that do not start with the typical VBM prefix of 
% strongly preprocessed images that can not be used for preprocessing
% ^[^(^(p[0123]|^c[123]|^m[0w]|^iy_|^y_|^jac_|^te|^pc)])].*
%data.ufilter = '(^[^p][^0123c]).*'; 
data.num      = [1 Inf];
data.help     = {
  'Select highres raw data (e.g. T1 images) for processing. This assumes that there is one scan for each subject. Note that multi-spectral (when there are two or more registered images of different contrasts) processing is not yet implemented for this method and each images is processed separately.'};


%_______________________________________________________________________
tpm         = cfg_files;
tpm.tag     = 'tpm';
tpm.name    = 'Tissue Probability Map';
tpm.filter  = 'image';
tpm.ufilter = '.*';
tpm.def     =  @(val)cg_vbm_get_defaults('opts.tpm', val{:});
tpm.num     = [1 1];
tpm.help    = {
  'Select the tissue probability image for this class. These should be maps of eg grey matter, white matter or cerebro-spinal fluid probability. A nonlinear deformation field is estimated that best overlays the tissue probability maps on the individual subjects'' image. The default tissue probability maps are modified versions of the ICBM Tissue Probabilistic Atlases. These tissue probability maps are kindly provided by the International Consortium for Brain Mapping, John C. Mazziotta and Arthur W. Toga. http://www.loni.ucla.edu/ICBM/ICBM_TissueProb.html.'
  ''
  'The original data are derived from 452 T1-weighted scans, which were aligned with an atlas space, corrected for scan inhomogeneities, and classified into grey matter, white matter and cerebrospinal fluid. These data were then affine registered to the MNI space and down-sampled to 2mm resolution.Rather than assuming stationary prior probabilities based upon mixing proportions, additional information is used, based on other subjects'' brain images. Priors are usually generated by registering a large number of subjects together, assigning voxels to different tissue types and averaging tissue classes over subjects. The algorithm used here will employ these priors for the first initial segmentation and normalization. Six tissue classes are used: grey matter, white matter, cerebro-spinal fluid, bone, non-brain soft tissue and air outside of the head and in nose, sinus and ears. These maps give the prior probability of any voxel in a registered image being of any of the tissue classes - irrespective of its intensity.The model is refined further by allowing the tissue probability maps to be deformed according to a set of estimated parameters. This allows spatial normalisation and segmentation to be combined into the same model.Selected tissue probability map must be in multi-volume nifti format and contain all six tissue priors. '
''
};

%------------------------------------------------------------------------
% various options for estimating the segmentations
%------------------------------------------------------------------------

ngaus         = cfg_entry;
ngaus.tag     = 'ngaus';
ngaus.name    = 'Gaussians per class';
ngaus.strtype = 'n';
ngaus.num     = [1 6];
ngaus.def     = @(val)cg_vbm_get_defaults('opts.ngaus', val{:});
ngaus.help    = {
'The number of Gaussians used to represent the intensity distribution for each tissue class can be greater than one. In other words, a tissue probability map may be shared by several clusters. The assumption of a single Gaussian distribution for each class does not hold for a number of reasons. In particular, a voxel may not be purely of one tissue type, and instead contain signal from a number of different tissues (partial volume effects). Some partial volume voxels could fall at the interface between different classes, or they may fall in the middle of structures such as the thalamus, which may be considered as being either grey or white matter. Various other image segmentation approaches use additional clusters to model such partial volume effects. These generally assume that a pure tissue class has a Gaussian intensity distribution, whereas intensity distributions for partial volume voxels are broader, falling between the intensities of the pure classes. Unlike these partial volume segmentation approaches, the model adopted here simply assumes that the intensity distribution of each class may not be Gaussian, and assigns belonging probabilities according to these non-Gaussian distributions. Typical numbers of Gaussians could be two for grey matter, two for white matter, two for CSF, three for bone, four for other soft tissues and two for air (background).'
''
'Note that if any of the Num. Gaussians is set to non-parametric, then a non-parametric approach will be used to model the tissue intensities. This may work for some images (eg CT), but not others - and it has not been optimised for multi-channel data. Note that it is likely to be especially problematic for images with poorly behaved intensity histograms due to aliasing effects that arise from having discrete values on the images.'
''
};


%------------------------------------------------------------------------

biasreg        = cfg_menu;
biasreg.tag    = 'biasreg';
biasreg.name   = 'Bias regularisation';
biasreg.def    = @(val)cg_vbm_get_defaults('opts.biasreg', val{:});
biasreg.labels = {
  'no regularisation (0)','extremely light regularisation (0.00001)','very light regularisation (0.0001)','light regularisation (0.001)','medium regularisation (0.01)','heavy regularisation (0.1)','very heavy regularisation (1)','extremely heavy regularisation (10)'};
biasreg.values = {0, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1.0, 10};
biasreg.help   = {
  'MR images are usually corrupted by a smooth, spatially varying artifact that modulates the intensity of the image (bias). These artifacts, although not usually a problem for visual inspection, can impede automated processing of the images.An important issue relates to the distinction between intensity variations that arise because of bias artifact due to the physics of MR scanning, and those that arise due to different tissue properties.  The objective is to model the latter by different tissue classes, while modelling the former with a bias field. We know a priori that intensity variations due to MR physics tend to be spatially smooth, whereas those due to different tissue types tend to contain more high frequency information. A more accurate estimate of a bias field can be obtained by including prior knowledge about the distribution of the fields likely to be encountered by the correction algorithm. For example, if it is known that there is little or no intensity non-uniformity, then it would be wise to penalise large values for the intensity non-uniformity parameters. This regularisation can be placed within a Bayesian context, whereby the penalty incurred is the negative logarithm of a prior probability for any particular pattern of non-uniformity.Knowing what works best should be a matter of empirical exploration.  For example, if your data has very little intensity non-uniformity artifact, then the bias regularisation should be increased.  This effectively tells the algorithm that there is very little bias in your data, so it does not try to model it.'
''
};


%------------------------------------------------------------------------

biasfwhm        = cfg_menu;
biasfwhm.tag    = 'biasfwhm';
biasfwhm.name   = 'Bias FWHM';
biasfwhm.labels = {
  '30mm cutoff','40mm cutoff','50mm cutoff','60mm cutoff','70mm cutoff','80mm cutoff','90mm cutoff','100mm cutoff','110mm cutoff','120mm cutoff','130mm cutoff','140mm cutoff','150mm cutoff','No correction'};
biasfwhm.values = {30,40,50,60,70,80,90,100,110,120,130,140,150,Inf};
biasfwhm.def    = @(val)cg_vbm_get_defaults('opts.biasfwhm', val{:});
biasfwhm.help   = {
  'FWHM of Gaussian smoothness of bias. '
  ''
  'If your intensity non-uniformity is very smooth, then choose a large FWHM. This will prevent the algorithm from trying to model out intensity variation due to different tissue types. The model for intensity non-uniformity is one of i.i.d. Gaussian noise that has been smoothed by some amount, before taking the exponential. Note also that smoother bias fields need fewer parameters to describe them. This means that the algorithm is faster for smoother intensity non-uniformities.'
''
};

%------------------------------------------------------------------------

warpreg         = cfg_entry;
warpreg.def     = @(val)cg_vbm_get_defaults('opts.warpreg', val{:});
warpreg.tag     = 'warpreg';
warpreg.name    = 'Warping Regularisation';
warpreg.strtype = 'r';
warpreg.num     = [1 5];
warpreg.help    = {
  'The objective function for registering the tissue probability maps to the image to process, involves minimising the sum of two terms. One term gives a function of how probable the data is given the warping parameters. The other is a function of how probable the parameters are, and provides a penalty for unlikely deformations. Smoother deformations are deemed to be more probable. The amount of regularisation determines the tradeoff between the terms. Pick a value around one.  However, if your normalised images appear distorted, then it may be an idea to increase the amount of regularisation (by an order of magnitude). More regularisation gives smoother deformations, where the smoothness measure is determined by the bending energy of the deformations. '
};


%------------------------------------------------------------------------

affreg        = cfg_menu;
affreg.tag    = 'affreg';
affreg.name   = 'Affine Regularisation';
affreg.labels = {'No Affine Registration','ICBM space template - European brains','ICBM space template - East Asian brains','Average sized template','No regularisation'};
affreg.values = {'','mni','eastern','subj','none'};
affreg.def    = @(val)cg_vbm_get_defaults('opts.affreg', val{:});
affreg.help   = {
  'The procedure is a local optimisation, so it needs reasonable initial starting estimates. Images should be placed in approximate alignment using the Display function of SPM before beginning. A Mutual Information affine registration with the tissue probability maps (D''Agostino et al, 2004) is used to achieve approximate alignment. Note that this step does not include any model for intensity non-uniformity. This means that if the procedure is to be initialised with the affine registration, then the data should not be too corrupted with this artifact.If there is a lot of intensity non-uniformity, then manually position your image in order to achieve closer starting estimates, and turn off the affine registration.Affine registration into a standard space can be made more robust by regularisation (penalising excessive stretching or shrinking).  The best solutions can be obtained by knowing the approximate amount of stretching that is needed (e.g. ICBM templates are slightly bigger than typical brains, so greater zooms are likely to be needed). For example, if registering to an image in ICBM/MNI space, then choose this option.  If registering to a template that is close in size, then select the appropriate option for this.'
''
};

%------------------------------------------------------------------------

samp         = cfg_entry;
samp.tag     = 'samp';
samp.name    = 'Sampling distance';
samp.strtype = 'r';
samp.num     = [1 1];
samp.def    = @(val)cg_vbm_get_defaults('opts.samp', val{:});
samp.help   = {
  'This encodes the approximate distance between sampled points when estimating the model parameters. Smaller values use more of the data,  but the procedure is slower and needs more memory. Determining the "best" setting involves a compromise between speed and accuracy.'
''
};

%------------------------------------------------------------------------

opts      = cfg_branch;
opts.tag  = 'opts';
opts.name = 'Estimation options';
opts.val  = {tpm,biasreg,biasfwhm,affreg};
opts.help = {
  'Various options can be adjusted in order to improve the performance of the algorithm with your data.  Knowing what works best should be a matter of empirical exploration. However, most of the option work very well for a large variety of data and only for of high-field MR scanner bias regularization should be adapted to a lower value. Furthermore, for children data I strongly recommend to use customized TPMs created using the Template-O-Matic toolbox.'};

%_______________________________________________________________________
% options for output
%-----------------------------------------------------------------------

vox         = cfg_entry;
vox.tag     = 'vox';
vox.name    = 'Voxel size for normalized images';
vox.strtype = 'r';
vox.num     = [1 1];
vox.def     = @(val)cg_vbm_get_defaults('extopts.vox', val{:});
vox.help    = {
  'The (isotropic) voxel sizes of any spatially normalised written images. A non-finite value will be replaced by the average voxel size of the tissue probability maps used by the segmentation.'
''
};

%------------------------------------------------------------------------

bb         = cfg_entry;
bb.tag     = 'bb';
bb.name    = 'Bounding box';
bb.strtype = 'r';
bb.num     = [2 3];
bb.def     = @(val)cg_vbm_get_defaults('extopts.bb', val{:});
bb.help    = {'The bounding box (in mm) of the volume which is to be written (relative to the anterior commissure).'
''
};

%------------------------------------------------------------------------
% Species
%------------------------------------------------------------------------

%{
species        = cfg_menu;
species.tag    = 'species';
species.name   = 'Species';
species.labels = {'Humans','Greater apes (bonobos,chimpanzees,gorillas,orang-utans)','Lesser apes (gibbons)','Oldworld monkeys (baboons,maquaces)','Newworld monkeys'};
species.values = {'human','ape_greater','ape_lesser','monkey_oldworld','monkey_newworld'};
species.def    = @(val)cg_vbm_get_defaults('extopts.species', val{:});
species.help   = {
  'Preprocessing of other species requires special TPM, atlas and template maps.'
  'This option will modify other relevant parameter automaticly and is still in the development.'
};
%}

%------------------------------------------------------------------------
% Resolution
%------------------------------------------------------------------------

if expert
  resnative        = cfg_branch;
  resnative.tag    = 'native';
  resnative.name   = 'Native resolution preprocessing';
  resnative.help   = {
    'Preprocessing with native resolution.'
    'Because of special VBM12 optimization function and to void interpolation artifacts in Dartel output the lowest resolution is limited to 1.5 mm in all cases! Highes resolution is limited to 0.2 mm. '
    ''
    'Examples:'
    '  native resolution       internal resolution '
    '   0.95 0.95 1.05     >     0.95 0.95 1.05'
    '   0.45 0.45 1.70     >     0.45 0.45 1.50'
    '' 
  }; 

  resbest        = cfg_entry;
  resbest.tag    = 'best';
  resbest.name   = 'Best native resolution with interpolation boundary:';
  resbest.def    = @(val)cg_vbm_get_defaults('extopts.resval', val{:});
  resbest.num    = [1 2];
  resbest.help   = {
    'Preprocessing with the best (minimal) voxel dimension of the native image.'
    'The first value limits the interpolation, whereas the second value avoid interpolation of nearly correct resolutions.'
    'Because of special VBM12 optimization function and to void interpolation artifacts in Dartel output the lowest resolution is limited to 1.5 mm in all cases! Highes resolution is limited to 0.2 mm. '
    ''
    'Examples:'
    '  Parameters    native resolution       internal resolution'
    '  [1.00 0.10]    0.95 1.05 1.25     >     0.95 1.00 1.00'
    '  [1.00 0.10]    0.45 0.45 1.50     >     0.45 0.45 1.00'
    '  [0.75 0.10]    0.45 0.45 1.50     >     0.45 0.45 0.75'  
    '  [0.75 0.10]    0.45 0.45 0.80     >     0.45 0.45 0.80'  
    '  [0.00 0.10]    0.45 0.45 1.50     >     0.45 0.45 0.45'  
    ''
  }; 

  resfixed        = cfg_entry;
  resfixed.tag    = 'fixed';
  resfixed.name   = 'Fixed resolution';
  resfixed.def    = @(val)cg_vbm_get_defaults('extopts.resval', val{:});
  resfixed.num    = [1 2];
  resfixed.help   = {
    'The first value controls the resolution that is used, if the voxel resolution differ more than the second parameter from the first one. '
    'The second paramter is used to avoid small interpolation for nearly correct resolutions. ' 
    'Because of special VBM12 optimization function and to void interpolation artifacts in Dartel output the lowest resolution is limited to 1.5 mm in all cases! Highes resolution is limited to 0.2 mm. '
    ''
    'Examples: '
    '  Parameters     native resolution       internal resolution'
    '  [1.00 0.10]     0.45 0.45 1.70     >     1.00 1.00 1.00'
    '  [1.00 0.10]     0.95 1.05 1.25     >     0.95 1.05 1.00'
    '  [1.00 0.02]     0.95 1.05 1.25     >     1.00 1.00 1.00'
    '  [1.00 0.10]     0.95 1.05 1.25     >     0.95 1.05 1.00'
    '  [0.75 0.10]     0.75 0.95 1.25     >     0.75 1.75 0.75'
  }; 


  restype        = cfg_choice;
  restype.tag    = 'restype';
  restype.name   = 'Spatial resolution';
  switch cg_vbm_get_defaults('extopts.restype')
    case 'native', restype.val = {resnative};
    case 'best',   restype.val = {resbest};
    case 'fixed',  restype.val = {resfixed};
  end
  restype.values = {resnative resbest resfixed};
  restype.help   = {
    'There are 3 major ways to control the resolution ''native'', ''best'', and ''fixed''. Due to special optimization functions and Dartel low resolution output artifacts the lowest resolution is limited to 1.5 mm in all cases! Highest resolution is limited to 0.2 mm. '
    ''
    'We commend to use ''best'' for highrest quality. ' 
  }; 
end


%------------------------------------------------------------------------
% Cleanup
%------------------------------------------------------------------------

cleanup        = cfg_menu;
cleanup.tag    = 'cleanup';
cleanup.name   = 'Clean up any partitions';
cleanup.labels = {'No Cleanup','Light Cleanup','Thorough Cleanup','New Cleanup'};
cleanup.values = {0 1 2 3};
cleanup.def    = @(val)cg_vbm_get_defaults('extopts.cleanup', val{:});
cleanup.help   = {
  'This uses a crude routine for extracting the brain from segmentedimages. It begins by taking the white matter, and eroding it acouple of times to get rid of any odd voxels. The algorithmcontinues on to do conditional dilations for several iterations,where the condition is based upon gray or white matter being present.This identified region is then used to clean up the grey and whitematter partitions, and has a slight influences on the CSF partition.''If you find pieces of brain being chopped out in your data, then you may wish to disable or tone down the cleanup procedure.Cleanup==3 calls a new separate routine, that was designed especially for VBM preprocessing.'
''
};

cleanupstr         = cfg_entry;
cleanupstr.tag     = 'cleanupstr';
cleanupstr.name    = 'Strength of New Cleanup';
cleanupstr.strtype = 'r';
cleanupstr.num     = [1 1];
cleanupstr.def     = @(val)cg_vbm_get_defaults('extopts.cleanupstr', val{:});
cleanupstr.help    = {
  'Strengh of tissue cleanup after AMAP segmentation. The cleanup removes meninges and corrects for partial volume effects in special regions. The default 0.5 was successfully tested on a variety of scans. Use smaller values (>=0) for small changes and higher values (<=1) for stronger corrections. '
  ''
  'The strength changes multiple internal parameters: '
  ' 1) Size of the correction area'
  ' 2) Smoothing parameters to controll the opening processes to remove thin structures '
  ''
  'If parts of brain tissue were missing than decrease the strength.  If to many meninges are vissible than increase the strength. '
''
};

%------------------------------------------------------------------------

gcutstr         = cfg_entry;
gcutstr.tag     = 'gcutstr';
gcutstr.name    = 'Strength of gcut+ Skull-Stripping';
gcutstr.strtype = 'r';
gcutstr.num     = [1 1];
gcutstr.def     = @(val)cg_vbm_get_defaults('extopts.gcutstr', val{:});
gcutstr.help    = {
  'Strengh of skull-stripping, with 0 for a more liberal and wider brain masks and 1 for harder and closer results. The default is 0.5 and was ' 
  'successfully tested on a variety of scans. '
  ''
  'The strength changes multiple internal parameters: '
  ' 1) Intensity thresholds to deal with blood-vessels and meninges '
  ' 2) Distance and growing parameters for the graph-cut/region-growing '
  ' 3) Closing parameters that fill the sulci'
  ' 4) Smoothing parameters that allow sharper or wider results '
  ''
  'If parts of the brain were missing in the brain mask than decrease the strength.  If the brain mask of your images contains parts of the head, than increase the strength. '
''
};

%------------------------------------------------------------------------
% Noise correction
%------------------------------------------------------------------------
if expert
  sanlm        = cfg_menu;
  sanlm.tag    = 'sanlm';
  sanlm.name   = 'Use SANLM de-noising filter';
  sanlm.labels = {'No denoising','SANLM denoising','SANLM denoising (multi-threaded)',...
    'SANLM denoising + ORNLM','SANLM denoising (multi-threaded) + ORNLM'
  };
  sanlm.values = {0 1 2 3 4 5};
  sanlm.def    = @(val)cg_vbm_get_defaults('extopts.sanlm', val{:});
  sanlm.help   = {
    'This function applies an spatial adaptive non local means (SANLM) denoising filter to the data. This filter will remove noise while preserving edges. The smoothing filter size is automatically estimated based on the local variance in the image. Due to varying contrast a second NLM filter is used after inhomogeneity correction and intensity scaling in order to remove increased noise after local scaling. Using an option with ORNLM filter allows further modification of the strength of the noise correction. '
    'The following options are available: '
    '  0) No noise correction '
    '  1) SANLM '
    '  2) SANLM (multi-threaded) '
    '  3) SANLM + ORNLM 4) SANLM (multi-threaded) + ORNLM'
    '  5) Only ORNLM (with temporarily SANLM filter, but only one final noise correction of the original data)' 
  };
end

NCstr         = cfg_entry;
NCstr.tag     = 'NCstr';
NCstr.name    = 'Strength of Noise Corrections';
NCstr.strtype = 'r';
NCstr.num     = [1 1];
NCstr.def     = @(val)cg_vbm_get_defaults('extopts.NCstr', val{:});
NCstr.help    = {
  'Strengh of the SANLM, ORNLM and MRF noise correction. The default 0.5 was successfully tested on a variety of scans. Use smaller values (>0) for small changes and higher values (<=1) for stronger denoising. The value 0 will turn off any noise correction!'
''
};

%------------------------------------------------------------------------
% Local Adapative Segmentation
%------------------------------------------------------------------------

LAS        = cfg_menu;
LAS.tag    = 'LAS';
LAS.name   = 'Local Adaptive Segmentation';
LAS.labels = {'no','yes'};
LAS.values = {0 1};
LAS.def    = @(val)cg_vbm_get_defaults('extopts.LAS', val{:});
LAS.help   = {
  'Adaption for local intensity changes of WM, GM and CSF for medium/low spatial frequencies.The changes are clear visible in subcortical GM areas. This function will also improve the inhomogeneity correction. '
  ''
  'See also ...'
  ''
};

LASstr         = cfg_entry;
LASstr.tag     = 'LASstr';
LASstr.name    = 'Strength of Local Adaptive Segmentation';
LASstr.strtype = 'r';
LASstr.num     = [1 1];
LASstr.def     = @(val)cg_vbm_get_defaults('extopts.LASstr', val{:});
LASstr.help    = {
  'Strengh of the modification by the Local Adaptive Segmenation (LAS). The default 0.5 was successfully tested on a variety of scans. Use smaller values (>0) for small changes and higher values (<=1) for stronger corrections. The value 0 will deactive LAS.'
  ''
};

%------------------------------------------------------------------------
% WM Hyperintensities:
%------------------------------------------------------------------------

WMHC        = cfg_menu;
WMHC.tag    = 'WMHC';
WMHC.name   = 'WM Hyperintensity Correction';
WMHC.labels = {'no WMHC','temporary WMHCWMHC - correction to WM like SPM','WMHC - correction to a separate class'};
WMHC.values = {0 1 2 3};
WMHC.def    = @(val)cg_vbm_get_defaults('extopts.WMHC', val{:});
WMHC.help   = {
  'In aging or diseases WM intensity be strongly reduces in T1 or increased in T2/PD images. These so called WM hyperintensies (WMHs) can lead to preprocessing errors. Large GM areas next to the ventricle can cause normalization problems. Therefore, a temporary correction for the normalization is meaningfull, if WMHs were expected. As far as these changes are an important marker, VBM allow different ways to handel WMHs. '
  ''
  ' 0) No Correction (like VBM8). '
  '     - Take care of large WMHs with normalization problems. '
  '     - Consider that GM in unexpected regions represent WMCs.  '
  ' 1) Temporary Correction for normalization. '
  '     - Consider that GM in unexpected regions represent WMCs.  '
  ' 2) Correction to WM (like SPM). ' 
  ' 3) Correction to separate class. '
  ''
  'See also ...'
''
};

WMHCstr         = cfg_entry;
WMHCstr.tag     = 'WMHCstr';
WMHCstr.name    = 'Strength of WMH Correction';
WMHCstr.strtype = 'r';
WMHCstr.num     = [1 1];
WMHCstr.def     = @(val)cg_vbm_get_defaults('extopts.WMHCstr', val{:});
WMHCstr.help    = {
  'Strengh of the modification of the WM Hyperintensity Correction (WMHC). The default 0.5 was successfully tested on a variety of scans. Use smaller values (>0) for small changes and higher values (<=1) for stronger corrections. The value 0 will deactive WMHC.'
''
};

%------------------------------------------------------------------------

ROI        = cfg_menu;
ROI.tag    = 'ROI';
ROI.name   = 'ROI analyis';
ROI.labels = {'no ROI analyis','subject space ROI analysis','template space ROI analyis','both'};
ROI.values = {0 1 2 3};
ROI.def    = @(val)cg_vbm_get_defaults('extopts.ROI', val{:});
ROI.help   = {
  'Export of ROI data of volume, intensity, and thickness to csv-files. The values of a ROI can be estimated in subject and/or normalized spaced. '
  ''
  'For thickness estimation the projection-based thickness (PBT) [Dahnke:2012] is used that estimates cortical thickness for each GM voxel. Although, this maps can be mapped to different spaces the analysis is difficult, because many statistical asumptions do not fit. Therefore, only ROI-based values are available. To overcome this limitation surface-based analysis functions for VBM are in development. '
  ''
  'There are different atlas maps available: '
  '(1) Anatomy Toolbox Maps (Version 2.0, 2014-07-23)' 
  '    References for the SPM Anatomy toolbox:'
  '    1) Eickhoff SB, Stephan KE, Mohlberg H, Grefkes C, Fink GR, Amunts K, Zilles K. A new SPM toolbox for combining probabilistic cytoarchitectonic maps and functional imaging data. NeuroImage 25(4), 1325-1335, 2005'
  '    2) Eickhoff SB, Heim S, Zilles K, Amunts K. Testing anatomically specified hypotheses in functional imaging using cytoarchitectonic maps. NeuroImage 32(2), 570-582, 2006'
  '    3) Eickhoff SB, Paus T, Caspers S, Grosbras MH, Evans A, Zilles K, Amunts K. Assignment of functional activations to probabilistic cytoarchitectonic areas revisited. NeuroImage 36(3), 511-521, 2007'
  ''
  '    References for probabilistic cytoarchitectonic mapping:'
  '    1) Zilles K, Amunts K. Centenary of Brodmann?s map ? conception and fate. Nature Reviews Neuroscience 11(2), 2010: 139-145 '
  '    2) Amunts K, Schleicher A, Zilles K). Cytoarchitecture of the cerebral cortex ? more than localization. Neuroimage 37, 2007: 1061-1065.'
  '    3) Zilles K, Schleicher A, Palomero-Gallagher N, Amunts K. Quantitative analysis of cyto- and receptor architecture of the human brain. Brain Mapping: The Methods, J. C. Mazziotta and A. Toga (eds.), USA: Elsevier, 2002, p. 573-602.'
  ''
  '(2) Hammers:'
  '    Alexander Hammers brain atlas from the Euripides project: '
  '    www.brain-development.org'
  ''
  '    Hammers A, Allom R, Koepp MJ, Free SL, Myers R, Lemieux L, Mitchell TN, Brooks DJ, Duncan JS. Three-dimensional maximum probability atlas of the human brain, with particular reference to the temporal lobe. Hum Brain Mapp 2003, 19: 224-247.'
''
};

%------------------------------------------------------------------------

print        = cfg_menu;
print.tag    = 'print';
print.name   = 'Display and print results';
print.labels = {'yes','no'};
print.values = {1 0};
print.def    = @(val)cg_vbm_get_defaults('extopts.print', val{:});
print.help   = {
'The normalized T1 image and the normalized segmentations can be displayed and printed to a ps-file. This is often helpful to check whether registration and segmentation were successful. However, this is only working if you write normalized images.'
''
};

%------------------------------------------------------------------------

surface        = cfg_menu;
surface.tag    = 'surface';
surface.name   = 'Surface and thickness estimation';
surface.labels = {'yes','no'};
surface.values = {1 0};
surface.def    = @(val)cg_vbm_get_defaults('extopts.surface', val{:});
surface.help   = {
  'Use PBT (Dahnke et al. 2012) to estimate cortical thickness and to create the central cortical surface for left and right hemissphere. Surface reconstruction include topology correction (Yotter et al. 2011) and spherical projection (Yotter et al.).'
''
};

%------------------------------------------------------------------------

darteltpm         = cfg_files;
darteltpm.tag     = 'darteltpm';
darteltpm.name    = 'Dartel Template';
darteltpm.filter  = 'image';
darteltpm.ufilter = '_1_';
darteltpm.def     = @(val)cg_vbm_get_defaults('extopts.darteltpm', val{:});
darteltpm.num     = [1 1];
darteltpm.help    = {
   'Selected tissue probability map must be in multi-volume nifti format and contain all six tissue priors.'
''
};

%------------------------------------------------------------------------

extopts       = cfg_branch;
extopts.tag   = 'extopts';
extopts.name  = 'Extended options';
if expert
  extopts.val   = {sanlm,NCstr,LASstr,gcutstr,cleanupstr,darteltpm,ROI,surface,restype,print}; 
else
  extopts.val   = {NCstr,LASstr,gcutstr,cleanupstr,darteltpm,ROI,surface,print}; 
end
extopts.help  = {'Using the extended options you can adjust the strength of different corrections ("0" means no correction and "0.5" is the default value that works best for a large variety of data). Furthermore, you can select additional options to create surface reconstructions, ROI analysis  etc.'};

%------------------------------------------------------------------------
% options for data
%------------------------------------------------------------------------

native        = cfg_menu;
native.tag    = 'native';
native.name   = 'Native space';
native.labels = {'none','yes'};
native.values = {0 1};
native.help   = {
  'The native space option allows you to produce a tissue class image (p*) that is in alignment with the original/* (see Figure \ref{seg1})*/. It can also be used for ''''importing'''' into a form that can be used with the DARTEL toolbox (rp*).'
''
};

warped        = cfg_menu;
warped.tag    = 'warped';
warped.name   = 'Normalized';
warped.labels = {'none','yes'};
warped.values = {0 1};
warped.help   = {'Write image in normalized space without any modulation.'
''
};

affine        = cfg_menu;
affine.tag    = 'affine';
affine.name   = 'Affine';
affine.labels = {'none','yes'};
affine.values = {0 1};
affine.help   = {'Write image in normalized space, but restricted to affine transformation.'};

dartel        = cfg_menu;
dartel.tag    = 'dartel';
dartel.name   = 'DARTEL export';
dartel.labels = {'none','rigid (SPM12 default)','affine'};
dartel.values = {0 1 2};
dartel.help   = {
'This option is to export data into a form that can be used with DARTEL.The SPM default is to only apply rigid body transformation. However, a more appropriate option is to apply affine transformation, because the additional scaling of the images requires less deformations to non-linearly register brains to the template.'
''
};

native.def  = @(val)cg_vbm_get_defaults('output.bias.native', val{:});
warped.def  = @(val)cg_vbm_get_defaults('output.bias.warped', val{:});
affine.def  = @(val)cg_vbm_get_defaults('output.bias.affine', val{:});
bias        = cfg_branch;
bias.tag    = 'bias';
bias.name   = 'Bias Corrected';
bias.val    = {native, warped, affine};
bias.help   = {
  'This is the option to save a bias, noise, and (local) intensity correctedversion of the original T1 image. MR images are usually corrupted by a smooth, spatially varying artifact that modulates the intensity of the image (bias). These artifacts, although not usually a problem for visual inspection, can impede automated processing of the images. The bias corrected version should have more uniform intensities within the different types of tissues and can be saved in native space and/or normalised.Noise is corrected by an adaptive non-local mean (NLM) filter (Manjon 2008, Medical Image Analysis 12).'
''
};


%------------------------------------------------------------------------

warped.def    = @(val)cg_vbm_get_defaults('output.jacobian.warped', val{:});
jacobian      = cfg_branch;
jacobian.tag  = 'jacobian';
jacobian.name = 'Jacobian determinant';
jacobian.val  = {warped};
jacobian.help = {
  'This is the option to save the Jacobian determinant, which expresses local volume changes. This image can be used in a pure deformation based morphometry (DBM) design.'
''
};

%------------------------------------------------------------------------

native.def  = @(val)cg_vbm_get_defaults('output.label.native', val{:});
warped.def  = @(val)cg_vbm_get_defaults('output.label.warped', val{:});
dartel.def  = @(val)cg_vbm_get_defaults('output.label.dartel', val{:});

label       = cfg_branch;
label.tag   = 'label';
label.name  = 'PVE label image';
label.val   = {native, warped, dartel};
label.help  = {
'This is the option to save a labeled version of your segmentations. Labels are saved as Partial Volume Estimation (PVE) values with different mix classes for GM-WM (2.5) and GM-CSF (0.5). BG=0, CSF=1, GM=2, WM=3, WMH=4 (if WMHC=3)'
''
};

%------------------------------------------------------------------------

modulated        = cfg_menu;
modulated.tag    = 'modulated';
modulated.name   = 'Modulated normalized';
modulated.labels = {'none','affine + non-linear (SPM12 default)','non-linear only'};
modulated.values = {0 1 2};
modulated.help = {
'"Modulation" is to compensate for the effect of spatial normalisation. Spatial normalisation causes volume changes due to affine transformation (global scaling) and non-linear warping (local volume change). The SPM default is to adjust spatially normalised grey matter (or other tissue class) by using both terms and the resulting modulated images are preserved for the total amount of grey matter. Thus, modulated images reflect the grey matter volumes before spatial normalisation. However, the user is often interested in removing the confound of different brain sizes and there are many ways to apply this correction. We can use the total amount of GM, GM+WM, GM+WM+CSF, or manual estimated total intracranial volume (TIV). Theses parameters can be modeled as nuisance parameters (additive effects) in an AnCova model or used to globally scale the data (multiplicative effects): '
''
'% Correction   Interpretation'
'% ----------   --------------'
'% nothing      absolute volume'
'% globals 	     relative volume after correcting for total GM or TIV (multiplicative effects)'
'% AnCova 	      relative volume that can not be explained by total GM or TIV (additive effects)'
''
'I suggest another option to remove the confounding effects of different brain sizes. Modulated images can be optionally saved by correcting for non-linear warping only. Volume changes due to affine normalisation will be not considered and this equals the use of default modulation and globally scaling data according to the inverse scaling factor due to affine normalisation. I recommend this option if your hypothesis is about effects of relative volumes which are corrected for different brain sizes. This is a widely used hypothesis and should fit to most data. The idea behind this option is that scaling of affine normalisation is indeed a multiplicative (gain) effect and we rather apply this correction to our data and not to our statistical model. These modulated images are indicated by "m0" instead of "m". '
''
};

native.def    = @(val)cg_vbm_get_defaults('output.GM.native', val{:});
warped.def    = @(val)cg_vbm_get_defaults('output.GM.warped', val{:});
modulated.def = @(val)cg_vbm_get_defaults('output.GM.mod', val{:});
dartel.def    = @(val)cg_vbm_get_defaults('output.GM.dartel', val{:});
grey          = cfg_branch;
grey.tag      = 'GM';
grey.name     = 'Grey matter';
grey.val      = {native, warped, modulated, dartel};
grey.help     = {'Options to produce grey matter images: p1*.img, wp1*.img and mwp1*.img.'
''
};

native.def    = @(val)cg_vbm_get_defaults('output.WM.native', val{:});
warped.def    = @(val)cg_vbm_get_defaults('output.WM.warped', val{:});
modulated.def = @(val)cg_vbm_get_defaults('output.WM.mod', val{:});
dartel.def    = @(val)cg_vbm_get_defaults('output.WM.dartel', val{:});
white         = cfg_branch;
white.tag     = 'WM';
white.name    = 'White matter';
white.val     = {native, warped, modulated, dartel};
white.help    = {'Options to produce white matter images: p2*.img, wp2*.img and mwp2*.img.'
''
};

native.def    = @(val)cg_vbm_get_defaults('output.CSF.native', val{:});
warped.def    = @(val)cg_vbm_get_defaults('output.CSF.warped', val{:});
modulated.def = @(val)cg_vbm_get_defaults('output.CSF.mod', val{:});
dartel.def    = @(val)cg_vbm_get_defaults('output.CSF.dartel', val{:});
csf           = cfg_branch;
csf.tag       = 'CSF';
csf.name      = 'Cerebro-Spinal Fluid (CSF)';
csf.val       = {native, warped, modulated, dartel};
csf.help      = {'Options to produce CSF images: p3*.img, wp3*.img and mwp3*.img.'
''
};

native.def    = @(val)cg_vbm_get_defaults('output.WMH.native', val{:});
warped.def    = @(val)cg_vbm_get_defaults('output.WMH.warped', val{:});
dartel.def    = @(val)cg_vbm_get_defaults('output.WMH.dartel', val{:});
wmh           = cfg_branch;
wmh.tag       = 'WMH';
wmh.name      = 'White matter hyperintensity (WMH)';
wmh.val       = {native, warped, dartel};
wmh.help      = {'Options to produce WMH images, if WMHC==3: p4*.img, wp4*.img and mwp4*.img.'
''
};

% main structure atlas
native.def    = @(val)cg_vbm_get_defaults('output.atlas.native', val{:});
warped.def    = @(val)cg_vbm_get_defaults('output.atlas.warped', val{:});
dartel.def    = @(val)cg_vbm_get_defaults('output.atlas.dartel', val{:});
atlas         = cfg_branch;
atlas.tag     = 'atlas';
atlas.name    = 'Atlas label maps';
atlas.val     = {native, warped, dartel};
atlas.help    = {
  'WARNING: The functions that create this maps are still under development! This is the option to save an atlas map with major structures (a1*). Odd numbers code the left, even numbers the right hemisphere. Furthermore, AAL and Broadman atlas maps were created based on maps from MRIcron that where adapted to the other VBM maps. Other maps are used from the IBASPM toolbox.  http://www.thomaskoenig.ch/Lester/ibaspm.htmAnatomy toolbox:Alexander Hammers brain atlas from the Euripides project:   www.brain-development.org  Hammers A, Allom R, Koepp MJ, Free SL, Myers R, Lemieux L, Mitchell   TN, Brooks DJ, Duncan JS. Three-dimensional maximum probability atlas   of the human brain, with particular reference to the temporal lobe.   Hum Brain Mapp 2003, 19: 224-247.'
''
};


% preprocessing change map
native.def   = @(val)cg_vbm_get_defaults('output.pc.native', val{:});
warped.def   = @(val)cg_vbm_get_defaults('output.pc.warped', val{:});
dartel.def   = @(val)cg_vbm_get_defaults('output.pc.dartel', val{:});
pc           = cfg_branch;
pc.tag       = 'pc';
pc.name      = 'preprocessing change map';
pc.val       = {native, warped, dartel};
pc.help      = {
  'WARNING: The preprocessing documentation map is under development!\n\nThis is the option to save a map that protocol the canges that were necessary to segment your image. In example the removement of blood vessels or the adaption for local GM intensity will result in strong modifications of the orignal image. Although this corrections normaly helps to improve segmenation quality they can fail. As a result higher values describe regions where error are more likely than in other regions. '
''
};


% tissue expectation map
native.def   = @(val)cg_vbm_get_defaults('output.te.native', val{:});
warped.def   = @(val)cg_vbm_get_defaults('output.te.warped', val{:});
dartel.def   = @(val)cg_vbm_get_defaults('output.te.dartel', val{:});
te           = cfg_branch;
te.tag       = 'te';
te.name      = 'tissue expectation map';
te.val       = {native, warped, dartel};
te.help      = {
  'WARNING: The preprocessing documentation map is under development!\n\nDifference image of the atlas map in subject space and the segmentation.' };



warps = cfg_menu;
warps.tag    = 'warps';
warps.name   = 'Deformation Fields';
warps.labels = {
    'none'
    'Image->Template (forward)'
    'Template->Image (inverse)'
    'inverse + forward'};
warps.values = {[0 0],[1 0],[0 1],[1 1]};
warps.def    = @(val)cg_vbm_get_defaults('output.warps', val{:});
warps.help   = {
  'Deformation fields can be saved to disk, and used by the Deformations Utility. For spatially normalising images to MNI space, you will need the forward deformation, whereas for spatially normalising (eg) GIFTI surface files, you''ll need the inverse. It is also possible to transform data in MNI space on to the individual subject, which also requires the inverse transform. Deformations are saved as .nii files, which contain three volumes to encode the x, y and z coordinates.'
''
};

%------------------------------------------------------------------------

output      = cfg_branch;
output.tag  = 'output';
output.name = 'Writing options';
output.val  = {grey, white, csf, label, bias, jacobian, warps}; % wmh, ,atlas, pc, te};
output.help = {
'There are a number of options about what data you would like the routine to produce. The routine can be used for producing images of tissue classes, as well as bias corrected images. The native space option will produce a tissue class image (p*) that is in alignment with the original image. You can also produce spatially normalised versions - both with (m[0]wrp*) and without (wrp*) modulation. In the vbm toolbox, the voxel size of the spatially normalised versions is 1.5 x 1.5 x 1.5mm as default. The produced images of the tissue classes can directly be used for doing voxel-based morphometry (both un-modulated and modulated). All you need to do is smooth them and do the stats (which means no more questions on the mailing list about how to do "optimized VBM").'
''
'Modulation is to compensate for the effect of spatial normalisation. When warping a series of images to match a template, it is inevitable that volumetric differences will be introduced into the warped images. For example, if one subject''s temporal lobe has half the volume of that of the template, then its volume will be doubled during spatial normalisation. This will also result in a doubling of the voxels labeled grey matter. In order to remove this confound, the spatially normalised grey matter (or other tissue class) is adjusted by multiplying by its relative volume before and after warping. If warping results in a region doubling its volume, then the correction will halve the intensity of the tissue label. This whole procedure has the effect of preserving the total amount of grey matter signal in the normalised partitions.'
''
'A deformation field is a vector field, where three values are associated with each location in the field. The field maps from co-ordinates in the normalised image back to co-ordinates in the original image. The value of the field at co-ordinate [x y z] in the normalised space will be the co-ordinate [x'' y'' z''] in the original volume. The gradient of the deformation field at a co-ordinate is its Jacobian matrix, and it consists of a 3x3 matrix:'
'%   /                      \%   | dx''/dx  dx''/dy dx''/dz |%   |                       |%   | dy''/dx  dy''/dy dy''/dz |%   |                       |%   | dz''/dx  dz''/dy dz''/dz |%   \                      /'
''
'The value of dx''/dy is a measure of how much x'' changes if y is changed by a tiny amount. The determinant of the Jacobian is the measure of relative volumes of warped and unwarped structures.  The modulation step simply involves multiplying by the relative volumes.'};

%------------------------------------------------------------------------

estwrite        = cfg_exbranch;
estwrite.tag    = 'estwrite';
estwrite.name   = 'VBM12: Estimate & Write';
estwrite.val    = {data,opts,extopts,output};
estwrite.prog   = @cg_vbm_run;
estwrite.vout   = @vout;
estwrite.help   = {
'This toolbox is an extension of the default segmentation in SPM12, but uses a completely different segmentation approach.'
''
'The segmentation approach is based on an Adaptive Maximum A Posterior (MAP) technique without the need for a priori information about tissue probabilities. That is, the Tissue Probability Maps (TPM) are not used constantly in the sense of the classical Unified Segmentation approach (Ashburner et. al. 2005), but just for spatial normalization. The following AMAP estimation is adaptive in the sense that local variations of the parameters (i.e., means and variance) are modeled as slowly varying spatial functions (Rajapakse et al. 1997). This not only accounts for intensity inhomogeneities but also for other local variations of intensity.'
''
'Additionally, the segmentation approach uses a Partial Volume Estimation (PVE) with a simplified mixed model of at most two tissue types (Tohka et al. 2004). We start with an initial segmentation into three pure classes: gray matter (GM), white matter (WM), and cerebrospinal fluid (CSF) based on the above described AMAP estimation. The initial segmentation is followed by a PVE of two additional mixed classes: GM-WM and GM-CSF. This results in an estimation of the amount (or fraction) of each pure tissue type present in every voxel (as single voxels - given by their size - probably contain more than one tissue type) and thus provides a more accurate segmentation.'
''
'Another important extension to the SPM12 segmentation is the integration of the Dartel normalisation (Ashburner 2007) into the toolbox by an already existing Dartel template in MNI space. This template was derived from 555 healthy control subjects of the IXI-database (http://www.brain-development.org) and provides the six Dartel iteration. Thus, for the majority of studies the creation of sample-specific Dartel templates is not necessary anymore.'};

%------------------------------------------------------------------------

write        = cfg_exbranch;
write.tag    = 'write';
write.name   = 'VBM12: Write already estimated segmentations';
write.val    = {data,extopts,output};
write.prog   = @cg_vbm_run;
write.vout   = @vout;
write.help   = {
'Allows previously estimated segmentations (stored in imagename''_seg8.mat'' files) to save the segmented images only without estimating the segmentation again. This might be helpful if you have already estimated segmentations and you need an additional tissue class, or you want to change voxel size of segmented images,'};

%------------------------------------------------------------------------
tools = cg_vbm_tools;
%------------------------------------------------------------------------

vbm        = cfg_choice;
vbm.name   = 'VBM12';
vbm.tag    = 'vbm';
vbm.values = {estwrite,write,tools};
%------------------------------------------------------------------------

%------------------------------------------------------------------------
function dep = vout(job)

opts  = job.output;

tissue(1).warped = [opts.GM.warped  (opts.GM.modulated==1)  (opts.GM.modulated==2) ];
tissue(1).native = [opts.GM.native  (opts.GM.dartel==1)     (opts.GM.dartel==2)    ];
tissue(2).warped = [opts.WM.warped  (opts.WM.modulated==1)  (opts.WM.modulated==2) ];
tissue(2).native = [opts.WM.native  (opts.WM.dartel==1)     (opts.WM.dartel==2)    ];
tissue(3).warped = [opts.CSF.warped (opts.CSF.modulated==1) (opts.CSF.modulated==2)];
tissue(3).native = [opts.CSF.native (opts.CSF.dartel==1)    (opts.CSF.dartel==2)   ];

% This depends on job contents, which may not be present when virtual
% outputs are calculated.

cdep = cfg_dep;
cdep(end).sname      = 'Seg Params';
cdep(end).src_output = substruct('.','param','()',{':'});
cdep(end).tgt_spec   = cfg_findspec({{'filter','mat','strtype','e'}});


% bias corrected
if opts.bias.native,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Bias Corr Images';
    cdep(end).src_output = substruct('()',{1}, '.','biascorr','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.bias.warped,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Warped Bias Corr Images';
    cdep(end).src_output = substruct('()',{1}, '.','wbiascorr','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;


% label
if opts.label.native,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Label Images';
    cdep(end).src_output = substruct('()',{1}, '.','label','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.label.warped,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Warped Label Images';
    cdep(end).src_output = substruct('()',{1}, '.','wlabel','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.label.dartel==1,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Rigid Registered Label Images';
    cdep(end).src_output = substruct('()',{1}, '.','rlabel','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.label.dartel==2,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Affine Registered Label Images';
    cdep(end).src_output = substruct('()',{1}, '.','alabel','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;

% atlas
if isfield(opts,'atlas')
  if opts.atlas.native,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Atlas Images';
      cdep(end).src_output = substruct('()',{1}, '.','atlas','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.atlas.warped,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Warped Atlas Images';
      cdep(end).src_output = substruct('()',{1}, '.','watlas','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.atlas.dartel==1,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Rigid Registered Atlas Images';
      cdep(end).src_output = substruct('()',{1}, '.','ratlas','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.atlas.dartel==2,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Affine Registered Atlas Images';
      cdep(end).src_output = substruct('()',{1}, '.','aatlas','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
end

% pc
if isfield(opts,'pc')
  if opts.pc.native,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','pc','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.pc.warped,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Warped Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','wpc','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.pc.dartel==1,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Rigid Registered Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','rpc','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.pc.dartel==2,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Affine Registered Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','apc','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
end

% te
if isfield(opts,'te')
  if opts.te.native,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','te','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.te.warped,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Warped Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','wte','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.te.dartel==1,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Rigid Registered Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','rte','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
  if opts.te.dartel==2,
      cdep(end+1)          = cfg_dep;
      cdep(end).sname      = 'Affine Registered Preprocessing Change Images';
      cdep(end).src_output = substruct('()',{1}, '.','ate','()',{':'});
      cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
  end;
end


% jacobian
if opts.jacobian.warped,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Jacobian Determinant Images';
    cdep(end).src_output = substruct('()',{1}, '.','jacobian','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;

% warps
if opts.warps(1),
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Deformation Field';
    cdep(end).src_output = substruct('()',{1}, '.','fordef','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.warps(2),
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Inverse Deformation Field';
    cdep(end).src_output = substruct('()',{1}, '.','invdef','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;

% tissues
for i=1:numel(tissue),
    if tissue(i).native(1),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('p%d Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','c','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end
    if tissue(i).native(2),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('rp%d rigid Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','rc','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end
    if tissue(i).native(3),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('rp%d affine Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','rca','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end
    if tissue(i).warped(1),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('wp%d Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','wc','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end
    if tissue(i).warped(2),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('mwp%d Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','mwc','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end
    if tissue(i).warped(3),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('m0wp%d Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','m0wc','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end
end



dep = cdep;



